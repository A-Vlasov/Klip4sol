const l="http://213.159.215.121:8000/api";async function _(s){console.log(`[API] Fetching token info for: ${s}`),console.log(`[API] Request URL: ${l}/token/${s}`);try{const e=await fetch(`${l}/token/${s}`);if(console.log(`[API] Token info response status: ${e.status}`),!e.ok){const o=await e.text();throw console.error(`[API] Token info error: ${e.status} - ${o}`),new Error(`Server error: ${e.status} - ${o}`)}const r=await e.json();return console.log("[API] Token info data received:",r),r}catch(e){throw console.error("[API] Token info fetch failed:",e),e}}async function h(s){console.log(`[API] Fetching top buyers for: ${s}`);try{const e=await fetch(`${l}/token/${s}/top-buyers`);if(console.log(`[API] Top buyers response status: ${e.status}`),!e.ok){const o=await e.text();throw console.error(`[API] Top buyers error: ${e.status} - ${o}`),new Error(`Server error: ${e.status} - ${o}`)}const r=await e.json();return console.log("[API] Top buyers data received:",r),r}catch(e){throw console.error("[API] Top buyers fetch failed:",e),e}}async function f(s){console.log(`[API] Fetching security info for: ${s}`);try{const e=await fetch(`${l}/token/${s}/security`);if(console.log(`[API] Security response status: ${e.status}`),!e.ok){const o=await e.text();throw console.error(`[API] Security error: ${e.status} - ${o}`),new Error(`Server error: ${e.status} - ${o}`)}const r=await e.json();return console.log("[API] Security data received:",r),r}catch(e){throw console.error("[API] Security fetch failed:",e),e}}async function y(s){console.log(`[API] Fetching token price for: ${s}`);try{const e=await fetch(`${l}/token/${s}/price`);if(console.log(`[API] Price response status: ${e.status}`),!e.ok){const o=await e.text();throw console.error(`[API] Price error: ${e.status} - ${o}`),new Error(`Server error: ${e.status} - ${o}`)}const r=await e.json();return console.log("[API] Price data received:",r),r}catch(e){throw console.error("[API] Price fetch failed:",e),e}}async function g(s){console.log(`[API] Fetching rugcheck data for: ${s}`),console.log(`[API] Request URL: ${l}/token/${s}/rugcheck`);try{const e=await fetch(`${l}/token/${s}/rugcheck`);if(console.log(`[API] Rugcheck response status: ${e.status}`),console.log(`[API] Rugcheck response status: ${e.status}`),!e.ok){const n=await e.text();throw console.error(`[API] Rugcheck error: ${e.status} - ${n}`),new Error(`Rugcheck API error: ${e.status} - ${n}`)}const r=await e.json();console.log("[Rugcheck] Raw data:",r);let o=[];return r.risks&&Array.isArray(r.risks)&&(o=r.risks.map(n=>typeof n=="string"?n:typeof n=="object"&&n!==null?n.name||n.description||n.value||JSON.stringify(n):String(n))),{status:r.status||"unknown",score:r.score||0,risk_factors:o,message:r.message,rugged:r.rugged,mint:r.mint,name:r.name,symbol:r.symbol,liquidity:r.liquidity,detectedAt:r.detectedAt,links:r.links}}catch(e){throw console.error("[API] Rugcheck fetch failed:",e),e}}function m(s){try{chrome.tabs.query({},e=>{e.forEach(r=>{r.id!==void 0&&chrome.tabs.sendMessage(r.id,s,()=>{})})})}catch(e){console.warn("[ServiceWorker] broadcastMessage failed",e)}}async function u(s){try{console.log(`[Analyzer] Fetching analysis for token: ${s}`);const[e,r,o,n,c]=await Promise.allSettled([_(s),h(s),f(s),y(s),g(s)]);console.log("[Analyzer] Raw responses:",{tokenInfo:e.status==="fulfilled"?e.value:null,topBuyers:r.status==="fulfilled"?r.value:null,securityInfo:o.status==="fulfilled"?o.value:null,priceInfo:n.status==="fulfilled"?n.value:null,rugcheckData:c.status==="fulfilled"?c.value:null});const a={};if(e.status==="fulfilled"){const t=e.value;console.log("[Analyzer] Token info data:",t),a.tokenInfo={name:t.name,symbol:t.symbol,address:t.address,logo:t.logo,decimals:t.decimals,marketCap:t.market_cap,fdv:t.fdv,price:t.price,price_1m:t.price_1m,price_5m:t.price_5m,price_1h:t.price_1h,price_6h:t.price_6h,price_24h:t.price_24h,volume_1m:t.volume_1m,volume_5m:t.volume_5m,volume_1h:t.volume_1h,volume_6h:t.volume_6h,volume_24h:t.volume_24h,swaps_1m:t.swaps_1m,swaps_5m:t.swaps_5m,swaps_1h:t.swaps_1h,swaps_6h:t.swaps_6h,swaps_24h:t.swaps_24h,buys_1m:t.buys_1m,buys_5m:t.buys_5m,buys_1h:t.buys_1h,buys_6h:t.buys_6h,buys_24h:t.buys_24h,sells_1m:t.sells_1m,sells_5m:t.sells_5m,sells_1h:t.sells_1h,sells_6h:t.sells_6h,sells_24h:t.sells_24h,net_in_volume_1m:t.net_in_volume_1m,net_in_volume_5m:t.net_in_volume_5m,net_in_volume_1h:t.net_in_volume_1h,net_in_volume_6h:t.net_in_volume_6h,net_in_volume_24h:t.net_in_volume_24h,holder_count:t.holder_count,total_supply:t.total_supply,max_supply:t.max_supply,liquidity:t.liquidity,biggest_pool_address:t.biggest_pool_address,open_timestamp:t.open_timestamp,social_links:t.link||{},link:t.link||{},bundlers:t.bundlers,circulating_supply:t.circulating_supply},a.stats={holders:t.holder_count||0,transactions24h:t.swaps_24h||0,liquidity:t.liquidity||0,burnedTokens:0}}if(r.status==="fulfilled"&&r.value){const t=r.value;console.log("[Analyzer] Top buyers data:",t),t.holderInfo&&(a.topBuyers=t.holderInfo.map(i=>({wallet:i.wallet_address||i.wallet,status:i.status,tags:i.tags,maker_token_tags:i.maker_token_tags})),a.topBuyersMeta={holder_count:t.holder_count,statusNow:t.statusNow})}if(c.status==="fulfilled"?a.securityInfo=c.value:o.status==="fulfilled"&&(a.securityInfo=o.value),n.status==="fulfilled"&&n.value){const t=n.value;console.log("[Analyzer] Price data:",t),a.tokenInfo||(a.tokenInfo={}),a.tokenInfo.price=t.usd_price||t.price}return console.log("[Analyzer] Final analysis:",a),a}catch(e){return console.error("[Analyzer] Error fetching token analysis:",e),{error:e instanceof Error?e.message:"Unknown error occurred"}}}chrome.runtime.onMessage.addListener((s,e,r)=>{if(console.log("[ServiceWorker] Received message:",s),s.type==="TOKEN_DETECTED"){console.log("[ServiceWorker] Processing TOKEN_DETECTED for address:",s.address);const o=s.address;chrome.storage.local.set({lastToken:o}),u(o).then(n=>{chrome.storage.local.set({[`analysis_${o}`]:n});const c={type:"ANALYSIS_READY",address:o,analysis:n};chrome.runtime.sendMessage(c)}).catch(n=>{console.error("[ServiceWorker] Analysis failed:",n)})}if(s.type==="GET_ANALYSIS"){const o=s.address;return o?(console.log(`[ServiceWorker] Analyzing address: ${o}`),u(o).then(r),!0):(chrome.storage.local.get("lastToken",n=>{n.lastToken?(console.log(`[ServiceWorker] Analyzing last token: ${n.lastToken}`),u(n.lastToken).then(r)):(console.log("[ServiceWorker] No address to analyze"),r(null))}),!0)}if(s.type==="SHOW_NOTIFICATION"){const{title:o,message:n,contracts:c}=s;chrome.notifications.create({type:"basic",iconUrl:"icons/icon48.png",title:o,message:n,priority:1}),chrome.storage.local.set({detectedContracts:c,lastDetectionTime:Date.now()})}if(s.type==="CONTRACT_ANALYZE"){const{address:o,contractType:n}=s;return console.log(`[ServiceWorker] Analyzing contract: ${o} (${n})`),u(o).then(c=>{chrome.storage.local.set({[`contract_analysis_${o}`]:c}),chrome.runtime.sendMessage({type:"CONTRACT_ANALYSIS_READY",address:o,analysis:c,contractType:n}),m({type:"CONTRACT_ANALYSIS_READY",address:o,analysis:c,contractType:n});try{r==null||r({status:"done"})}catch{}}).catch(c=>{console.error("[ServiceWorker] Contract analysis failed:",c);try{r==null||r({status:"error",message:String(c)})}catch{}}),!0}if(s.type==="CONTRACT_CLICKED"){const{address:o,contractType:n}=s;console.log(`[ServiceWorker] Contract clicked: ${o} (${n})`),chrome.storage.local.set({lastToken:o}),chrome.storage.local.get(`contract_analysis_${o}`,c=>{c[`contract_analysis_${o}`]||u(o).then(a=>{chrome.storage.local.set({[`contract_analysis_${o}`]:a})})}),chrome.action.openPopup()}if(s.type==="CONTRACTS_DETECTED"){const{contracts:o}=s;console.log("[ServiceWorker] Contracts detected:",o),chrome.storage.local.set({detectedContracts:o,lastDetectionTime:Date.now()})}});
